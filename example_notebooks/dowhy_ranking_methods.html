<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>&lt;no title&gt; &mdash; DoWhy | An end-to-end library for causal inference  documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
        <script>window.MathJax = {"tex": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true}, "options": {"ignoreHtmlClass": "tex2jax_ignore|mathjax_ignore|document", "processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
        <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../index.html" class="icon icon-home"> DoWhy | An end-to-end library for causal inference
          </a>
              <div class="version">
                0.8
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Getting Started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../getting_started/intro.html">Introduction to DoWhy</a></li>
<li class="toctree-l1"><a class="reference internal" href="../getting_started/install.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="dowhy_simple_example.html">Quick-start notebook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../getting_started/comparison.html">Comparison to other packages</a></li>
<li class="toctree-l1"><a class="reference internal" href="../getting_started/cite.html">Citing this package</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">User Guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../user_guide/causality_intro.html">Introduction to causality</a></li>
<li class="toctree-l1"><a class="reference internal" href="../user_guide/effect_inference/index.html">Effect inference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../user_guide/gcm_based_inference/index.html">GCM-based inference (Experimental)</a></li>
<li class="toctree-l1"><a class="reference internal" href="nb_index.html">Example notebooks</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Tutorials/Case studies</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="tutorial-causalinference-machinelearning-using-dowhy-econml.html">CATE estimation with DoWhy+EconML</a></li>
<li class="toctree-l1"><a class="reference internal" href="dowhy_example_effect_of_memberrewards_program.html">Effect of membership rewards program</a></li>
<li class="toctree-l1"><a class="reference internal" href="DoWhy-The%20Causal%20Story%20Behind%20Hotel%20Booking%20Cancellations.html">Understanding hotel booking cancellations</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Contributing</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../contributing/index.html">Contributing to DoWhy</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Package</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../code_repo.html">Code repository &amp; Versions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dowhy.html">dowhy package</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">DoWhy | An end-to-end library for causal inference</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
      <li>&lt;no title&gt;</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/example_notebooks/dowhy_ranking_methods.ipynb.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  
<style>
/* CSS overrides for sphinx_rtd_theme */

/* 24px margin */
.nbinput.nblast.container,
.nboutput.nblast.container {
    margin-bottom: 19px;  /* padding has already 5px */
}

/* ... except between code cells! */
.nblast.container + .nbinput.container {
    margin-top: -19px;
}

.admonition > p:before {
    margin-right: 4px;  /* make room for the exclamation icon */
}

/* Fix math alignment, see https://github.com/rtfd/sphinx_rtd_theme/pull/686 */
.math {
    text-align: unset;
}
</style>
<dl>
<dt>{</dt><dd><dl>
<dt>“cells”: [</dt><dd><dl>
<dt>{</dt><dd><p>“cell_type”: “markdown”,
“metadata”: {},
“source”: [</p>
<blockquote>
<div><p>“## Ranking of estimation methods for a given dataset “</p>
</div></blockquote>
<p>]</p>
</dd>
</dl>
<p>},
{</p>
<blockquote>
<div><p>“cell_type”: “markdown”,
“metadata”: {},
“source”: [</p>
<blockquote>
<div><p>“We illustrate the comparison of various estimation methods for a given datasets by ranking them according to their performance against refutation tests accounting for both the observed unmodelled confounding error and unobserved confounding error. “</p>
</div></blockquote>
<p>]</p>
</div></blockquote>
<p>},
{</p>
<blockquote>
<div><p>“cell_type”: “code”,
“execution_count”: null,
“metadata”: {},
“outputs”: [],
“source”: [</p>
<blockquote>
<div><p>“# Importing all the required librariesn”,
“import sysn”,
“import argparsen”,
“import xgboostn”,
“import numpy as npn”,
“import pandas as pdn”,
“import osn”,
“import pdbn”,
“import randomn”,
“from xgboost import XGBRegressorn”,
“from sklearn.preprocessing import PolynomialFeaturesn”,
“from sklearn.linear_model import LassoCVn”,
“from sklearn.ensemble import RandomForestRegressor, RandomForestClassifier, GradientBoostingRegressorn”,
“from sklearn.linear_model import LogisticRegressionCVn”,
“from sklearn.metrics import mean_absolute_errorn”,
“from dowhy import CausalModeln”,
“from datetime import datetimen”,
“from collections import namedtuplen”,
“n”,
“import statsmodels.api as smn”,
“from sklearn import linear_modeln”,
“n”,
“import dowhyn”,
“from dowhy.utils import dgpn”,
“from dowhy.utils.dgps.linear_dgp import LinearDataGeneratingProcessn”,
“from dowhy import CausalModeln”,
“from datetime import datetimen”,
“from collections import namedtuplen”,
“from dowhy.causal_refuters.add_unobserved_common_cause import AddUnobservedCommonCausen”,
“n”,
“import matplotlib.pyplot as pltn”,
“import matplotlib.lines as mlinesn”,
“import matplotlib.transforms as mtransformsn”,
“n”,
“# Config dict to set the logging leveln”,
“import logging.confign”,
“DEFAULT_LOGGING = {n”,
”    ‘version’: 1,n”,
”    ‘disable_existing_loggers’: False,n”,
”    ‘loggers’: {n”,
”        ‘’: {n”,
”            ‘level’: ‘WARN’,n”,
”        },n”,
”    }n”,
“}n”,
“n”,
“logging.config.dictConfig(DEFAULT_LOGGING)n”,
“# Disabling warnings outputn”,
“import warningsn”,
“from sklearn.exceptions import DataConversionWarning, ConvergenceWarningn”,
“warnings.filterwarnings(action=’ignore’, category=DataConversionWarning)n”,
“warnings.filterwarnings(action=’ignore’, category=ConvergenceWarning)n”</p>
</div></blockquote>
<p>]</p>
</div></blockquote>
<p>},
{</p>
<blockquote>
<div><p>“cell_type”: “code”,
“execution_count”: null,
“metadata”: {},
“outputs”: [],
“source”: [</p>
<blockquote>
<div><p>“def convert_singleton_to_float(arr):n”,
”    ‘’’Helper function.’’’n”,
”    array = []n”,
“n”,
”    if len(arr) == 1 and type(arr[0]) != np.ndarray:n”,
”        return arr[0]n”,
“n”,
”    for element in arr:n”,
”        while type(element) == np.ndarray or isinstance(element, list) :n”,
”            if len(element) &gt; 1:n”,
”                raise ValueError(&quot;This script only accepts one value for the refute&quot;)n”,
”            element = element[0]n”,
”        array.append(element)n”,
“n”,
”    return array”</p>
</div></blockquote>
<p>]</p>
</div></blockquote>
<p>},
{</p>
<blockquote>
<div><p>“cell_type”: “code”,
“execution_count”: null,
“metadata”: {},
“outputs”: [],
“source”: [</p>
<blockquote>
<div><p>“def ensure_dir(file_path):n”,
”    directory = os.path.dirname(file_path)n”,
”    if not os.path.exists(directory):n”,
”        os.makedirs(directory)n”,
“n”,
“RESULTSFOLDER = &quot;results/&quot;n”,
“ensure_dir(RESULTSFOLDER)n”,
“# Create the estimator named tuple to wrap the name and propertiesn”,
“Estimator = namedtuple(‘Estimator’, [‘name’,’params’])n”,
“Refuter = namedtuple(‘Refuter’, [‘name’,’params’])n”,
“n”,
“class Experiment():n”,
”    ‘’’n”,
”    Class to define the experiment setup to compare a list of estimators across a list of refuters for the given dataset. n”,
”    ‘’’n”,
”    def __init__(self, <a href="#id1"><span class="problematic" id="id2">**</span></a>kwargs):n”,
”        self.experiment_name = kwargs[‘experiment_name’]n”,
”        self.experiment_id = kwargs[‘experiment_id’]n”,
”        self.num_experiments = kwargs[‘num_experiments’]n”,
”        self.sample_sizes = kwargs[‘sample_sizes’]n”,
”        self.dgps = kwargs[‘dgps’]n”,
”        self.estimators = kwargs[‘estimators’]n”,
”        self.refuters = kwargs[‘refuters’]n”,
”        self.results = []n”,
”        self.simulate_unobserved_confounding = kwargs[&quot;simulate_unobserved_confounding&quot;]n”,
“n”,
”        # Handle input errors in sample_sizesn”,
”        if isinstance(self.sample_sizes, list) == False:n”,
”            if type(self.sample_sizes) != int:n”,
”                raise ValueError(‘The input to &quot;sample_sizes&quot; should be an int or a list’)n”,
”            else:n”,
”                self.sample_sizes = [self.sample_sizes]n”,
“n”,
”        # Handle input errors in DGPsn”,
”        if isinstance(self.dgps, list) == False:n”,
”            if isinstance(self.dgps, DataGeneratingProcess) == False:n”,
”                raise ValueError(‘The input to &quot;dgps&quot; should be a list or a subclass of &quot;DataGeneratingProcess&quot;’)n”,
”            else:n”,
”                self.dgps = [self.dgps]n”,
“n”,
”        # Handle inputs errors in estimatorsn”,
”        if isinstance(self.estimators, list) == False:n”,
”            if isinstance(self.estimators, Estimator) == False:n”,
”                raise ValueError(‘The input to &quot;estimators&quot; should be a list or an Estimator namedtuple’)n”,
”            else:n”,
”                self.estimators = [self.estimators]n”,
“n”,
”        # Handle input errors in refutersn”,
”        if isinstance(self.refuters, list) == False:n”,
”            if isinstance(self.refuters, Refuter) == False:n”,
”                raise ValueError(‘The input to &quot;refuters&quot; should be a list of a Refuter namedtuple’)n”,
”            else:n”,
”                self.refuters = [self.refuters]n”,
“n”,
”    def experiment(self):n”,
”        print(&quot;\n\nRunning Experiment:&quot;,self.experiment_name + ‘_’ + str(self.experiment_id) )n”,
“n”,
”        for exp in range(self.num_experiments):n”,
”            print(&quot;\n\nRunning Experiment Number:&quot;,exp)n”,
“n”,
”            for sample_size in self.sample_sizes:n”,
“n”,
”                print(&quot;\n\nCurrent Sample Size:&quot;,sample_size)n”,
“n”,
”                for dgp in self.dgps:n”,
”                    print(&quot;\n\nThe current DGP:&quot;)n”,
”                    print(dgp)n”,
”                    estimates = []n”,
”                    estimate_values = []n”,
”                    estimated_effect = []n”,
”                    new_effect = []n”,
”                    p_value = []n”,
”                    data = dgp.generate_data(sample_size)n”,
”                    print(&quot;printing data shape&quot;)n”,
”                    print(data.values.shape)n”,
”                    print(dgp.true_value)n”,
”                    print(&quot;check&quot;)n”,
”                    if dgp.treatment_is_binary:n”,
”                        data[dgp.treatment] = data[dgp.treatment].astype(bool)n”,
”                    #k = len(dgp.confounder)-4n”,
”                    #confounder_list = random.sample(dgp.confounder, k)n”,
”                    confounder_list = [‘w2’,’w3’]n”,
“n”,
”                    n”,
”                    s = set(confounder_list)n”,
”                    unobserved_confounders = [x for x in dgp.confounder if x not in s]n”,
”                    df_unobserved_confounders = pd.DataFrame(data = data[[c for c in data.columns if c in unobserved_confounders]])n”,
“n”,
”                    df_unobserved_confounders.to_csv(&quot;results/unobserved_confounders.csv&quot;)n”,
”                    print(&quot;printing length of confounder list:&quot;, len(confounder_list))n”,
”                    print(&quot;printing confounder list:&quot;, confounder_list)n”,
“n”,
”                    n”,
“n”,
”                    print(&quot;data columns&quot;)n”,
”                    n”,
”                    print(&quot;data columns&quot;, data.columns)n”,
”                    model = CausalModel(n”,
”                        data = data,n”,
”                        treatment = dgp.treatment,n”,
”                        outcome = dgp.outcome,n”,
”                        common_causes = confounder_list,n”,
”                        effect_modifiers = dgp.effect_modifiern”,
”                    )n”,
”                    model.view_model()n”,
”                    from IPython.display import Image, displayn”,
”                    display(Image(filename=&quot;causal_model.png&quot;))n”,
“n”,
”                    identified_estimand = model.identify_effect(proceed_when_unidentifiable=True)n”,
”                    n”,
”                    print(&quot;identified_estimand:&quot;, identified_estimand)n”,
”                    #print(&quot;identified_estimand:&quot;, identified_estimand)n”,
”                    print(&quot;\n\nRunning the estimators:\n&quot;)n”,
”                    for estimator in self.estimators:n”,
”                        print(&quot;The current estimator:&quot;, estimator)n”,
”                        print(&quot;estimator.params&quot;, estimator.params)n”,
”                        estimate = model.estimate_effect(n”,
”                            identified_estimand,n”,
”                            method_name = estimator.name,n”,
”                            method_params = estimator.paramsn”,
”                        )n”,
”                        print(&quot;printing estimate’s type&quot;)n”,
”                        print(type(estimate))n”,
”                        estimates.append(estimate)n”,
”                        estimate_values.append(estimate.value)n”,
”                    estimate_values = convert_singleton_to_float(estimate_values)n”,
”                    print(&quot;estimate_values&quot;, estimate_values)n”,
”                    print(&quot;\n\nRunning the refuters:\n&quot;)n”,
”                    for refuter in self.refuters:n”,
”                        print(&quot;The current refuter:&quot;, refuter)n”,
”                        n”,
”                        for estimate in estimates:n”,
”                            if self.simulate_unobserved_confounding == True:n”,
”                                print(&quot;<a href="#id3"><span class="problematic" id="id4">**</span></a><a href="#id5"><span class="problematic" id="id6">**</span></a><a href="#id7"><span class="problematic" id="id8">**</span></a><a href="#id9"><span class="problematic" id="id10">**</span></a>%%%%%%%%%$$$$$&amp;&amp;^**^^^^*^*^*&quot;)n”,
”                                if refuter.name == ‘dummy_outcome_refuter’:n”,
”                                    add_unobserved_confounder = AddUnobservedCommonCause(data, identified_estimand, estimate)n”,
”                                    print(&quot;add_unobserved_confounder&quot;, add_unobserved_confounder)n”,
”                                    unobserved_confounder_values = add_unobserved_confounder.include_simulated_confounder(convergence_threshold = 0.11, c_star_max = 1500)n”,
”                                    refuter.params[‘unobserved_confounder_values’] = unobserved_confounder_valuesn”,
”                                    print(‘refuter.params’, refuter.params)n”,
”                            refute = model.refute_estimate(n”,
”                                identified_estimand,n”,
”                                estimate,n”,
”                                method_name = refuter.name,n”,
”                                <a href="#id11"><span class="problematic" id="id12">**</span></a>refuter.params,n”,
”    n”,
”                                n”,
“n”,
”                            )n”,
”                            print(&quot;printing refute’s type&quot;)n”,
”                            print(type(refute))n”,
”                            if(refuter.name == ‘dummy_outcome_refuter’):n”,
”                                refute = refute[0]n”,
”                            if refute.refutation_result is not None:n”,
”                                p_value.append(refute.refutation_result[‘p_value’])n”,
”                            else:n”,
”                                p_value.append(None) n”,
“n”,
”                            estimated_effect.append(refute.estimated_effect)n”,
”                            #print(&quot;refute.estimate_effect()&quot;, refute.estimate_effect())n”,
”                            new_effect.append(refute.new_effect)n”,
“n”,
”                    estimated_effect = convert_singleton_to_float(estimated_effect)n”,
”                    new_effect = convert_singleton_to_float(new_effect)n”,
”                    p_value = convert_singleton_to_float(p_value)n”,
”                    true_value = convert_singleton_to_float(dgp.true_value)n”,
”                    n”,
”                    print(&quot;estimated effect&quot;, estimated_effect)n”,
”                    print(&quot;new_effect&quot;, new_effect)n”,
”                    print(&quot;p_value&quot;, p_value)n”,
”                    print(&quot;true value&quot;, true_value)n”,
”                    self.results.append([exp, sample_size, dgp.NAME, <a href="#id13"><span class="problematic" id="id14">*</span></a>estimate_values, <a href="#id15"><span class="problematic" id="id16">*</span></a>estimated_effect, <a href="#id17"><span class="problematic" id="id18">*</span></a>new_effect, <a href="#id19"><span class="problematic" id="id20">*</span></a>p_value, true_value])n”,
“n”,
“n”,
”        print(&quot;\n\nCompleted all experiments. Saving the data…&quot;)n”,
“n”,
”        COLUMNS = [‘EXPERIMENT’, ‘SAMPLE_SIZE’, ‘DGP’]n”,
”        RESULT_CATEGORIES = [‘ESTIMATED_EFFECT’, ‘NEW_EFFECT’, ‘P_VALUE’]n”,
”        estimator_names = [estimator.name for estimator in self.estimators]n”,
”        refuter_names = [refuter.name for refuter in self.refuters]n”,
“n”,
”        for estimator_name in estimator_names:n”,
”            COLUMNS += [‘ORIGINAL_ESTIMATE’+ ‘:’ + estimator_name]n”,
“n”,
”        for result_category in RESULT_CATEGORIES:n”,
”            for refuter_name in refuter_names:n”,
”                for estimator_name in estimator_names:n”,
”                    COLUMNS += [refuter_name + ‘:’ + estimator_name + ‘:’ + result_category]n”,
“n”,
”        COLUMNS += [‘TRUE_VALUE’]n”,
“n”,
”        csv_file = RESULTSFOLDER + self.experiment_name+ ‘_’ + str(self.experiment_id) + ‘_’ + str(datetime.utcnow().date()) + ‘_data.csv’n”,
”        onlyres_csv_file = RESULTSFOLDER + &quot;<a href="#id21"><span class="problematic" id="id22">onlyres_</span></a>&quot;+ self.experiment_name+ ‘_’ + str(self.experiment_id) + ‘_’ + str(datetime.utcnow()) + ‘_data.csv’n”,
”        self.results = pd.DataFrame(data=self.results,columns=COLUMNS)n”,
”        self.results.to_csv(csv_file.replace(&quot; &quot;, &quot;&quot;), index=False)n”,
“n”,
”        print(&quot;Data has been saved in &quot;,csv_file)n”,
“n”,
”        return csv_file”</p>
</div></blockquote>
<p>]</p>
</div></blockquote>
<p>},
{</p>
<blockquote>
<div><p>“cell_type”: “code”,
“execution_count”: null,
“metadata”: {},
“outputs”: [],
“source”: [</p>
<blockquote>
<div><p>“#Defining the Data Generating Process n”,
“ldgp = LinearDataGeneratingProcess(treatment=[‘t1’], outcome=[‘y’], confounder=[‘w1’,’w2’, ‘w3’,’w4’,’w5’,’w6’], effect_modifier=[‘x1’,’x2’], seed=None, treatment_is_binary=True)n”,
“n”,
“#Defining the sample size n”,
“sample_size = 1000n”,
“n”,
“dgp_dict = {‘ldgp’:ldgp}n”,
“dgp_list = []n”,
“dgp_list.append( dgp_dict[‘ldgp’] )n”,
“n”,
“n”,
“# Create a namedtuple to store the name of the estimator and the parameters passedn”,
“estimator_list = [&quot;backdoor.linear_regression&quot;,n”,
”                  #&quot;backdoor.propensity_score_stratification&quot;,n”,
”                  &quot;backdoor.propensity_score_matching&quot;,n”,
”                  &quot;backdoor.propensity_score_weighting&quot;,n”,
”                  &quot;backdoor.econml.dml.DML&quot;,n”,
”                  &quot;backdoor.econml.dr.LinearDRLearner&quot;,n”,
”                  #&quot;backdoor.econml.metalearners.TLearner&quot;,n”,
”                  #&quot;backdoor.econml.metalearners.XLearner&quot;,n”,
”                  #&quot;backdoor.causalml.inference.meta.LRSRegressor&quot;,n”,
”                  #&quot;backdoor.causalml.inference.meta.XGBTRegressor&quot;,n”,
”                  #&quot;backdoor.causalml.inference.meta.MLPTRegressor&quot;,n”,
”                  #&quot;backdoor.causalml.inference.meta.BaseXRegressor&quot;n”,
”                ]n”,
“method_params= [    None,n”,
”                    #None,n”,
”                    { &quot;init_params&quot;:{} },n”,
”                    { &quot;init_params&quot;:{} },n”,
”                    {&quot;init_params&quot;:{‘model_y’:GradientBoostingRegressor(),n”,
”                                    ‘model_t’: GradientBoostingRegressor(),n”,
”                                    &quot;model_final&quot;:LassoCV(fit_intercept=False),n”,
”                                    ‘featurizer’:PolynomialFeatures(degree=1, include_bias=True)},n”,
”                     &quot;fit_params&quot;:{}},n”,
”                    {&quot;init_params&quot;:{ ‘model_propensity’: LogisticRegressionCV(cv=3, solver=’lbfgs’, multi_class=’auto’),n”,
”                        },n”,
”                    &quot;fit_params&quot;:{}n”,
”                    },n”,
”                    ‘’’{&quot;init_params&quot;: {‘models’: GradientBoostingRegressor(n_estimators=100, max_depth=6, min_samples_leaf=int(sample_size/100))n”,
”                                    },n”,
”                    &quot;fit_params&quot;:{}n”,
”                    },n”,
”                    {&quot;init_params&quot;:{‘models’: GradientBoostingRegressor(n_estimators=100, max_depth=6, min_samples_leaf=int(sample_size/100)),n”,
”                        ‘propensity_model’: RandomForestClassifier(n_estimators=100, max_depth=6,n”,
”                                                                              min_samples_leaf=int(sample_size/100))n”,
”                        },n”,
”                     &quot;fit_params&quot;:{}n”,
”                    },n”,
”                    {&quot;init_params&quot;:{},},n”,
”                    {&quot;init_params&quot;:{n”,
”                        ‘learner’:XGBRegressor()n”,
”                        }n”,
”                    }’’’n”,
”                ]n”,
“estimator_tuples = []n”,
“refuter_tuples = []n”,
“n”,
“refuter_list = [‘dummy_outcome_refuter’]n”,
“refuter_params = [{‘num_simulations’:5,’transformation_list’: [(‘random_forest’,{‘n_estimators’:100, ‘max_depth’:6})], ‘true_causal_effect’:(lambda x:0.5)}]n”,
“n”,
“n”,
“# Iterate through the names and parameters to create a list of namedtuplesn”,
“for name, param in zip(estimator_list,method_params):n”,
”    estimator_tuples.append(Estimator._make([name, param]))n”,
”    n”,
“for name, param in zip(refuter_list, refuter_params):n”,
”    refuter_tuples.append(Refuter._make([name, param]))n”</p>
</div></blockquote>
<p>]</p>
</div></blockquote>
<p>},
{</p>
<blockquote>
<div><p>“cell_type”: “code”,
“execution_count”: null,
“metadata”: {},
“outputs”: [],
“source”: [</p>
<blockquote>
<div><p>“def plot_MAEs(res):n”,
”    true_value_column = res.columns[-1]n”,
”    estimate_columns=res.columns[3:-1]n”,
”    #print(estimate_columns)n”,
”    #print(type(estimate_columns))n”,
”    estimate_columns.append(pd.Index(res[&quot;TRUE_VALUE&quot;]))n”,
”    #print(estimate_columns)n”,
”    fig, ax = plt.subplots()n”,
”    MAE ={}n”,
”    for colname in estimate_columns:n”,
”        if colname not in (‘ORIGINAL_ESTIMATE:backdoor.propensity_score_weighting’,):n”,
”                           #’ORIGINAL_ESTIMATE:backdoor.econml.metalearners.TLearner’):n”,
”            plt.plot(res[colname], res[&quot;TRUE_VALUE&quot;], marker=’o’, linestyle=&quot;None&quot;, label=colname)n”,
”            &quot;Mean Absolute Error (MAE): {}&quot;.format(mean_absolute_error(res[colname], res[&quot;TRUE_VALUE&quot;]))n”,
”            MAE[colname] = mean_absolute_error(res[colname], res[&quot;TRUE_VALUE&quot;])n”,
”    fig.suptitle(‘Calibration plot showing the accuracy of different causal estimators [P(T=1)=0.9]’)n”,
”    ax.set_xlabel(‘Estimated effect’)n”,
”    ax.set_ylabel(‘True causal effect’)n”,
”    plt.legend(loc=’upper center’, bbox_to_anchor=(0.5, -0.20),n”,
”              fancybox=True, shadow=True, ncol=2)n”,
”    plt.show()n”,
”    print(&quot;Printing MAE of various estimates: &quot;)n”,
”    MAE_values = {k: v for k, v in sorted(MAE.items(), key=lambda item: item[1], reverse = True)}n”,
”    for k,v in MAE_values.items():n”,
”        print(k, v)”</p>
</div></blockquote>
<p>]</p>
</div></blockquote>
<p>},
{</p>
<blockquote>
<div><p>“cell_type”: “code”,
“execution_count”: null,
“metadata”: {},
“outputs”: [],
“source”: [</p>
<blockquote>
<div><p>“def plot_estimators_and_refuters(refuter, estimator):   n”,
”    x = list(res[‘EXPERIMENT’])n”,
”    y1 = list(res[refuter+’:’+estimator+’:ESTIMATED_EFFECT’])n”,
”    y2 = list(res[refuter+’:’+estimator+’:NEW_EFFECT’])n”,
”    #print(res[‘TRUE_VALUE’])n”,
”    y3 = list(res[‘TRUE_VALUE’])n”,
”    y4 = list(res[refuter+’:’+estimator+’:P_VALUE’])n”,
”    plt.scatter(x, y1, c =&quot;blue&quot;, label = &quot;Estimated Effect&quot;) n”,
”    plt.scatter(x, y2, c =&quot;red&quot;, label = &quot;New Effect&quot;)n”,
”    plt.scatter(x, y3, c =&quot;green&quot;, label = &quot;True Value&quot;)n”,
”    plt.scatter(x, y4, c =&quot;yellow&quot;, label = &quot;P Value&quot;)n”,
”    plt.xlabel(&quot;EXPERIMENT&quot;) n”,
”    plt.ylabel(&quot;EFFECT&quot;)n”,
”    legend = plt.legend(loc=4, fontsize=’small’, fancybox=True)n”,
”    plt.title(estimator) n”,
”    plt.show()n”,
”    plt.savefig(estimator+’.png’)”</p>
</div></blockquote>
<p>]</p>
</div></blockquote>
<p>},
{</p>
<blockquote>
<div><p>“cell_type”: “code”,
“execution_count”: null,
“metadata”: {},
“outputs”: [],
“source”: [</p>
<blockquote>
<div><p>“def plot_deviations(estimator_list, deviation_list):n”,
”    plt.scatter(estimator_list, deviation_list)n”,
”    plt.xticks(estimator_list, estimator_list, rotation=’vertical’)n”,
”    plt.show()”</p>
</div></blockquote>
<p>]</p>
</div></blockquote>
<p>},
{</p>
<blockquote>
<div><p>“cell_type”: “markdown”,
“metadata”: {},
“source”: [</p>
<blockquote>
<div><p>“## Observed unmodelled confounding error”</p>
</div></blockquote>
<p>]</p>
</div></blockquote>
<p>},
{</p>
<blockquote>
<div><p>“cell_type”: “markdown”,
“metadata”: {},
“source”: [</p>
<blockquote>
<div><p>“For each estimator, we use dummy outcome refuter to check the observed unmodelled confounding error for each estimator. That is, we run the refutation test for each estimator only on the observed confounders and analyse what amount of confounding error is present unmodelled amongst the observed variables.”</p>
</div></blockquote>
<p>]</p>
</div></blockquote>
<p>},
{</p>
<blockquote>
<div><p>“cell_type”: “code”,
“execution_count”: null,
“metadata”: {</p>
<blockquote>
<div><p>“scrolled”: true</p>
</div></blockquote>
<p>},
“outputs”: [],
“source”: [</p>
<blockquote>
<div><p>“# Define the properties of the experimentn”,
“# The name of the experimentn”,
“# The experiment IDn”,
“# The number of experiments to be run with the SAME parametersn”,
“# The size of the samples to be runn”,
“# The list of DGPs to be runn”,
“# The list of estimatorsn”,
“observed_confounding_error = Experiment(n”,
”    experiment_name=’Test’,n”,
”    experiment_id=’1’,n”,
”    num_experiments=10, # 10n”,
”    sample_sizes=sample_size,n”,
”    dgps=dgp_list,n”,
”    estimators=estimator_tuples,n”,
”    refuters=refuter_tuples,n”,
”    simulate_unobserved_confounding = False n”,
“)n”,
“n”,
“# Run the experimentn”,
“res = pd.read_csv(observed_confounding_error.experiment())”</p>
</div></blockquote>
<p>]</p>
</div></blockquote>
<p>},
{</p>
<blockquote>
<div><p>“cell_type”: “code”,
“execution_count”: null,
“metadata”: {</p>
<blockquote>
<div><p>“scrolled”: true</p>
</div></blockquote>
<p>},
“outputs”: [],
“source”: [</p>
<blockquote>
<div><p>“#PLOTn”,
“#This plot shows the Mean Absolute Error of the Orginal Estimate from the true value and of the New Effect from n”,
“#the expected value for each estimator. n”,
“plot_MAEs(res)”</p>
</div></blockquote>
<p>]</p>
</div></blockquote>
<p>},
{</p>
<blockquote>
<div><p>“cell_type”: “markdown”,
“metadata”: {},
“source”: [</p>
<blockquote>
<div><p>“### Ranking based on Original Estimate”</p>
</div></blockquote>
<p>]</p>
</div></blockquote>
<p>},
{</p>
<blockquote>
<div><p>“cell_type”: “markdown”,
“metadata”: {},
“source”: [</p>
<blockquote>
<div><p>“The Original Estimate is calculated in the presence of the True Value (that is, the ground truth). However in many real life datasets, the ground truth may not be known. Hence, we want the ranking produced by our refutation tests to be in coherence with that obtained from the Original Estimates. According to the Original Estimate values, the ranking of the estimators should be as follows (the method with the least MAE should get the best rank):n”,
“1. DMLCateEstimator n”,
“2. LinearRegression n”,
“3. LinearDRLearner n”,
“4. Propensity Score Matching “</p>
</div></blockquote>
<p>]</p>
</div></blockquote>
<p>},
{</p>
<blockquote>
<div><p>“cell_type”: “code”,
“execution_count”: null,
“metadata”: {},
“outputs”: [],
“source”: [</p>
<blockquote>
<div><p>“estimator_list = [&quot;backdoor.linear_regression&quot;,n”,
”                  #&quot;backdoor.propensity_score_stratification&quot;,n”,
”                  &quot;backdoor.propensity_score_matching&quot;,n”,
”                  &quot;backdoor.econml.dml.DML&quot;,n”,
”                  &quot;backdoor.econml.dr.LinearDRLearner&quot;,n”,
”                  #&quot;backdoor.econml.metalearners.TLearner&quot;,n”,
”                  #&quot;backdoor.econml.metalearners.XLearner&quot;,n”,
”                  #&quot;backdoor.causalml.inference.meta.LRSRegressor&quot;,n”,
”                  #&quot;backdoor.causalml.inference.meta.XGBTRegressor&quot;,n”,
”                  #&quot;backdoor.causalml.inference.meta.MLPTRegressor&quot;,n”,
”                  #&quot;backdoor.causalml.inference.meta.BaseXRegressor&quot;n”,
”                ]”</p>
</div></blockquote>
<p>]</p>
</div></blockquote>
<p>},
{</p>
<blockquote>
<div><p>“cell_type”: “code”,
“execution_count”: null,
“metadata”: {},
“outputs”: [],
“source”: [</p>
<blockquote>
<div><p>“#This plot shows the deviation of the original estimate, the new effect and the estimated effect from the true value n”,
“refuter = ‘dummy_outcome_refuter’n”,
“deviation_list = []n”,
“for estimator in estimator_list:n”,
”    plot_estimators_and_refuters(refuter, estimator)n”,
”    avg_deviation = ((res[refuter+’:’+estimator+’:NEW_EFFECT’]).sum(axis=0))n”,
”    print(avg_deviation)n”,
”    deviation_list.append(avg_deviation)”</p>
</div></blockquote>
<p>]</p>
</div></blockquote>
<p>},
{</p>
<blockquote>
<div><p>“cell_type”: “code”,
“execution_count”: null,
“metadata”: {},
“outputs”: [],
“source”: [</p>
<blockquote>
<div><p>“plot_deviations(estimator_list, deviation_list)n”,
“for i in range(len(estimator_list)):n”,
”    print(estimator_list[i] +&quot;: &quot;+ str(deviation_list[i]))”</p>
</div></blockquote>
<p>]</p>
</div></blockquote>
<p>},
{</p>
<blockquote>
<div><p>“cell_type”: “code”,
“execution_count”: null,
“metadata”: {},
“outputs”: [],
“source”: [</p>
<blockquote>
<div><p>“{k: v for k, v in sorted(zip(estimator_list, deviation_list), key=lambda item: item[1], reverse = True)}n”</p>
</div></blockquote>
<p>]</p>
</div></blockquote>
<p>},
{</p>
<blockquote>
<div><p>“cell_type”: “markdown”,
“metadata”: {},
“source”: [</p>
<blockquote>
<div><p>“### Ranking based on New Effect (Refutatation results) “</p>
</div></blockquote>
<p>]</p>
</div></blockquote>
<p>},
{</p>
<blockquote>
<div><p>“cell_type”: “markdown”,
“metadata”: {},
“source”: [</p>
<blockquote>
<div><p>“The ranking based on absolute value of deviations is :n”,
“1. Propensity Score Matching n”,
“2. Linear DR Learner n”,
“3. DML CATE Estimator n”,
“4. Linear Regression”</p>
</div></blockquote>
<p>]</p>
</div></blockquote>
<p>},
{</p>
<blockquote>
<div><p>“cell_type”: “markdown”,
“metadata”: {},
“source”: [</p>
<blockquote>
<div><p>“Clearly, the observed unmodelled confounding error is not able to match the ranking based on the Original Estimate. It is not even able to tell that the clear winner amongst the methods according to the true value is DML CATE Estimator “</p>
</div></blockquote>
<p>]</p>
</div></blockquote>
<p>},
{</p>
<blockquote>
<div><p>“cell_type”: “markdown”,
“metadata”: {},
“source”: [</p>
<blockquote>
<div><p>“## Unobserved confounding error”</p>
</div></blockquote>
<p>]</p>
</div></blockquote>
<p>},
{</p>
<blockquote>
<div><p>“cell_type”: “markdown”,
“metadata”: {},
“source”: [</p>
<blockquote>
<div><p>“For each estimator, we now simulate unobserved confounders and check its effect using dummy outcome refuter to check the unobserved confounding error for each estimator. That is, we run the refutation test for each estimator not only on the observed confounder, but also on an unobserved confounder that we simulate using the AddUnobservedCommonCause class and analyse whether there is a strong confounder that is unobserved (missing) and needs to be accounted for. “</p>
</div></blockquote>
<p>]</p>
</div></blockquote>
<p>},
{</p>
<blockquote>
<div><p>“cell_type”: “code”,
“execution_count”: null,
“metadata”: {},
“outputs”: [],
“source”: [</p>
<blockquote>
<div><p>“unobserved_confounding_error = Experiment(n”,
”    experiment_name=’Test’,n”,
”    experiment_id=’2’,n”,
”    num_experiments=10, # 10n”,
”    sample_sizes=sample_size,n”,
”    dgps=dgp_list,n”,
”    estimators=estimator_tuples,n”,
”    refuters=refuter_tuples,n”,
”    simulate_unobserved_confounding = Truen”,
“)n”,
“n”,
“# Run the experimentn”,
“res = pd.read_csv(unobserved_confounding_error.experiment())”</p>
</div></blockquote>
<p>]</p>
</div></blockquote>
<p>},
{</p>
<blockquote>
<div><p>“cell_type”: “code”,
“execution_count”: null,
“metadata”: {},
“outputs”: [],
“source”: [</p>
<blockquote>
<div><p>“##This plot shows the Mean Absolute Error of the Orginal Estimate from the true value and of the New Effect from n”,
“#the expected value for each estimator.n”,
“plot_MAEs(res)”</p>
</div></blockquote>
<p>]</p>
</div></blockquote>
<p>},
{</p>
<blockquote>
<div><p>“cell_type”: “markdown”,
“metadata”: {},
“source”: [</p>
<blockquote>
<div><p>“### Ranking based on Original Estimate”</p>
</div></blockquote>
<p>]</p>
</div></blockquote>
<p>},
{</p>
<blockquote>
<div><p>“cell_type”: “markdown”,
“metadata”: {},
“source”: [</p>
<blockquote>
<div><p>“The Original Estimate is calculated in the presence of the True Value (that is, the ground truth). However in many real life datasets, the ground truth may not be known. Hence, we want the ranking produced by our refutation tests to be in coherence with that obtained from the Original Estimates. According to the Original Estimate values, the ranking of the estimators should be as follows (the method with the least MAE should get the best rank):n”,
“1. DMLCateEstimator n”,
“2. Propensity Score Matching n”,
“3. LinearRegression n”,
“4. LinearDRLearner “</p>
</div></blockquote>
<p>]</p>
</div></blockquote>
<p>},
{</p>
<blockquote>
<div><p>“cell_type”: “code”,
“execution_count”: null,
“metadata”: {},
“outputs”: [],
“source”: [</p>
<blockquote>
<div><p>“#This plot shows the deviation of the original estimate, the new effect and the estimated effect from the true valuen”,
“refuter = ‘dummy_outcome_refuter’n”,
“deviation_list = []n”,
“for estimator in estimator_list:n”,
”    plot_estimators_and_refuters(refuter, estimator)n”,
”    avg_deviation = ((res[refuter+’:’+estimator+’:NEW_EFFECT’]).sum(axis=0))n”,
”    print(avg_deviation)n”,
”    deviation_list.append(avg_deviation)”</p>
</div></blockquote>
<p>]</p>
</div></blockquote>
<p>},
{</p>
<blockquote>
<div><p>“cell_type”: “code”,
“execution_count”: null,
“metadata”: {},
“outputs”: [],
“source”: [</p>
<blockquote>
<div><p>“plot_deviations(estimator_list, deviation_list)n”,
“for i in range(len(estimator_list)):n”,
”    print(estimator_list[i] +&quot;: &quot;+ str(deviation_list[i]))”</p>
</div></blockquote>
<p>]</p>
</div></blockquote>
<p>},
{</p>
<blockquote>
<div><p>“cell_type”: “code”,
“execution_count”: null,
“metadata”: {},
“outputs”: [],
“source”: [</p>
<blockquote>
<div><p>“{k: v for k, v in sorted(zip(estimator_list, deviation_list), key=lambda item: item[1], reverse = True)}”</p>
</div></blockquote>
<p>]</p>
</div></blockquote>
<p>},
{</p>
<blockquote>
<div><p>“cell_type”: “markdown”,
“metadata”: {},
“source”: [</p>
<blockquote>
<div><p>“### Ranking based on New Effect (Refutatation results) “</p>
</div></blockquote>
<p>]</p>
</div></blockquote>
<p>},
{</p>
<blockquote>
<div><p>“cell_type”: “markdown”,
“metadata”: {},
“source”: [</p>
<blockquote>
<div><p>“The ranking based on absolute value of deviations is :n”,
“1. DMLn”,
“2. Linear DR Learner n”,
“3. Propensity Score Matchingn”,
“4. Linear Regression”</p>
</div></blockquote>
<p>]</p>
</div></blockquote>
<p>},
{</p>
<blockquote>
<div><p>“cell_type”: “markdown”,
“metadata”: {},
“source”: [</p>
<blockquote>
<div><p>“#### We can see that this ranking produces the same top-ranked estimator as the one based on Original Estimate. Thus ranking based on the unobserved confounding error solves the problem and gives us a close-to-correct ranking amongst methods.”</p>
</div></blockquote>
<p>]</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>],
“metadata”: {</p>
<blockquote>
<div><dl class="simple">
<dt>“kernelspec”: {</dt><dd><p>“display_name”: “Python 3 (ipykernel)”,
“language”: “python”,
“name”: “python3”</p>
</dd>
</dl>
<p>},
“language_info”: {</p>
<blockquote>
<div><dl class="simple">
<dt>“codemirror_mode”: {</dt><dd><p>“name”: “ipython”,
“version”: 3</p>
</dd>
</dl>
<p>},
“file_extension”: “.py”,
“mimetype”: “text/x-python”,
“name”: “python”,
“nbconvert_exporter”: “python”,
“pygments_lexer”: “ipython3”,
“version”: “3.8.12”</p>
</div></blockquote>
<p>},
“toc”: {</p>
<blockquote>
<div><p>“base_numbering”: 1,
“nav_menu”: {},
“number_sections”: false,
“sideBar”: true,
“skip_h1_title”: true,
“title_cell”: “Table of Contents”,
“title_sidebar”: “Contents”,
“toc_cell”: false,
“toc_position”: {},
“toc_section_display”: true,
“toc_window_display”: false</p>
</div></blockquote>
<p>},
“nbsphinx”: {</p>
<blockquote>
<div><p>“execute”: “never”</p>
</div></blockquote>
<p>},</p>
</div></blockquote>
<p>},
“nbformat”: 4,
“nbformat_minor”: 4</p>
</dd>
</dl>
<p>}</p>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, PyWhy contributors.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>